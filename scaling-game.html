<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Factory</title>
    <!-- Tailwind CSS Production -->
    <link href="https://cdn.jsdelivr.net/npm/@tailwindcss/ui@latest/dist/tailwind-ui.min.css" rel="stylesheet">
    <!-- React Dependencies (Development versions for better error messages) -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Use Babel Standalone's pre-compiled version -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.20/babel.min.js"></script>
    <script src="https://unpkg.com/lucide-react@latest/umd/lucide-react.min.js"></script>
    <script src="https://cdn.umami.is/script.js" data-website-id="25a7a9a8-359f-4f5f-a8a4-0ca1add617d9"></script>
</head>

<body>
    <div id="root"></div>

    <!-- Game Component -->
    <script type="text/babel" data-presets="react">

        // --- COMPONENTS ---

        // --- Reusable Style Constants ---
        const styles = {
            sectionTitle: 'text-xl font-bold mb-4',
            card: 'bg-gray-700 rounded-lg p-4',
            button: 'bg-blue-500 hover:bg-blue-600 px-3 py-1 rounded transition-colors text-sm',
            greenButton: 'bg-green-500 hover:bg-green-600 px-3 py-1 rounded transition-colors text-sm',
            label: 'text-sm text-gray-400',
            value: 'font-bold',
            progressBar: 'bg-gray-700 h-2 rounded',
            systemNavButton: (active) => `flex items-center space-x-2 px-4 py-2 rounded-lg transition-colors ${active ? 'bg-blue-500 text-white' : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`
        };

        // --- Utility Functions ---
        const format = {
            currency: (n) => n.toLocaleString(),
            modelSize: (p) => {
                if (p >= 1e12) return (p / 1e12) + 'T';
                if (p >= 1e9) return (p / 1e9) + 'B';
                if (p >= 1e6) return (p / 1e6) + 'M';
                return p.toString();
            }
        };

        // --- Base Components ---
        const SectionTitle = ({ children }) => (
            <h2 className={styles.sectionTitle}>{children}</h2>
        );

        const Card = ({ children }) => (
            <div className={styles.card}>{children}</div>
        );

        const LabeledValue = ({ label, value, labelClass = '', valueClass = '' }) => (
            <div>
                <div className={`${styles.label} ${labelClass}`}>{label}</div>
                <div className={`${styles.value} ${valueClass}`}>{value}</div>
            </div>
        );

        const Button = ({ onClick, children, style = styles.button }) => (
            <button onClick={onClick} className={style}>{children}</button>
        );

        const ProgressBar = ({ value, max, color = 'bg-blue-500' }) => (
            <div className={styles.progressBar}>
                <div className={`${color} h-full rounded`} style={{ width: `${Math.min(value / max, 1) * 100}%` }} />
            </div>
        );

        // --- Core Resource Bar Component ---
        function CoreResourceBar({ money, revPerSec, totalFlopsDisplay, currentPowerUsage, powerCapacity, solarPanels, windTurbines, heat }) {
            const renewablePower = solarPanels * 5 + windTurbines * 7;
            return (
                <div className="bg-gray-800 border-b border-gray-700 mb-4">
                    <div className="container mx-auto py-3 px-4">
                        <div className="flex justify-between items-center">
                            {/* Primary Resources */}
                            <div className="flex space-x-8">
                                <LabeledValue label="Revenue/sec" value={`+$${revPerSec.toFixed(2)}`} valueClass="text-green-400" />
                                <LabeledValue label="Available Money" value={`$${money.toFixed(2)}`} />
                            </div>

                            {/* Core Metrics */}
                            <div className="flex space-x-8">
                                <LabeledValue label="Total FLOPS" value={totalFlopsDisplay} />
                                <LabeledValue label="Power Usage" value={`${currentPowerUsage.toFixed(1)}/${powerCapacity + renewablePower} kW`} valueClass="text-yellow-400" />
                                <LabeledValue label="Heat" value={`${heat.toFixed(1)}/100`} valueClass="text-red-400" />
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // --- Core Loop Visualization Component ---
        function CoreLoopVisualization({ totalGPUs, parallelGroups, trainGPUs, revPerSec }) {
            return (
                <Card>
                    <div className="flex justify-between items-center">
                        <LabeledValue label="GPUs" value={`${totalGPUs} Total (${parallelGroups.reduce((a, b) => a + b, 0)} Groups)`} />
                        <LabeledValue label="Training" value={`${trainGPUs} Active GPUs`} />
                        <LabeledValue label="Revenue" value={`$${revPerSec.toFixed(2)}/sec`} />
                    </div>
                </Card>
            );
        }

        // --- System Navigation Component ---
        function SystemNavigation({ activeSystem, setActiveSystem }) {
            const systems = [
                { id: 'compute', label: 'Compute' },
                { id: 'training', label: 'Training' },
                { id: 'inference', label: 'Inference' },
                { id: 'power', label: 'Power' }
            ];

            return (
                <div className="flex space-x-4 mb-6">
                    {systems.map(system => (
                        <Button
                            key={system.id}
                            onClick={() => setActiveSystem(system.id)}
                            style={styles.systemNavButton(activeSystem === system.id)}
                        >
                            {system.label}
                        </Button>
                    ))}
                </div>
            );
        }

        // --- GPU Card Component ---
        function GPUCard({ type, name, flops, cost, count, parallelGroups, onBuy, onParallelize, parallelizeCost }) {
            return (
                <div className="bg-gray-800 p-3 rounded-lg">
                    <div className="flex justify-between items-center mb-2">
                        <div className="flex items-center gap-3">
                            <div className="font-bold">{name}</div>
                            <div className={styles.label}>${format.currency(cost)}</div>
                        </div>
                        <Button onClick={onBuy}>Buy GPU</Button>
                    </div>
                    <div className="flex justify-between items-center text-sm mb-2">
                        <div>Singles: {count}</div>
                        <div>Groups: {parallelGroups} × 4</div>
                    </div>
                    <div className="flex items-center justify-between">
                        <div className="text-xs text-gray-400">${format.currency(parallelizeCost)}</div>
                        <Button onClick={onParallelize} style={styles.greenButton}>
                            Parallelize 4 GPUs
                        </Button>
                    </div>
                </div>
            );
        }

        // --- GPU Management Component ---
        function GPUManagement({ gpuTypes, parallelGroups, buyGPU, parallelizeGPU, gpuTypeCosts, gpuTypeFlops }) {
            return (
                <Card>
                    <SectionTitle>GPU Management</SectionTitle>
                    <div className="space-y-2">
                        {gpuTypes.map((gpu, index) => (
                            <GPUCard
                                key={index}
                                type={index}
                                name={gpu.name}
                                flops={gpuTypeFlops[index]}
                                cost={gpuTypeCosts[index]}
                                count={gpu.count}
                                parallelGroups={parallelGroups[index]}
                                onBuy={() => buyGPU(index)}
                                onParallelize={() => parallelizeGPU(index)}
                                parallelizeCost={150000 + 75000 * parallelGroups[index]}
                            />
                        ))}
                    </div>
                </Card>
            );
        }

        // --- Training Center Component ---
        function TrainingCenter({ isTraining, currentModelParams, trainingProgress, trainGPUs, trainedModels, changeTrainGPU, setTrainGPUInput, startTraining, formatModelSize }) {
            return (
                <Card>
                    <SectionTitle>Model Training</SectionTitle>
                    <div className="space-y-3">
                        {/* Current Training */}
                        <div className="mb-4">
                            <div className="bg-gray-800 p-3 rounded-lg">
                                {isTraining && currentModelParams ? (
                                    <>
                                        <div className="flex justify-between mb-2">
                                            <span>{formatModelSize(currentModelParams)} Parameter Model</span>
                                            <span>{trainingProgress}%</span>
                                        </div>
                                        <ProgressBar
                                            value={trainingProgress}
                                            max={100}
                                            color="bg-purple-500"
                                        />
                                    </>
                                ) : (
                                    <div className="text-gray-500">No active training</div>
                                )}
                            </div>
                        </div>

                        {/* Training Controls */}
                        <div className="mb-4">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-bold">Training GPUs</span>
                                <div className="flex items-center space-x-2">
                                    <Button onClick={() => changeTrainGPU(-1)} style="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm">-</Button>
                                    <input
                                        type="number"
                                        className="border rounded w-16 p-1 text-sm text-center bg-gray-900"
                                        value={trainGPUs}
                                        onChange={(e) => setTrainGPUInput(e.target.value)}
                                    />
                                    <Button onClick={() => changeTrainGPU(1)} style="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm">+</Button>
                                </div>
                            </div>
                        </div>

                        {/* Model Options */}
                        <div className="grid grid-cols-3 gap-2">
                            {[1e6, 1e9, 1e10, 1e11, 1e12].map(params => (
                                <Button
                                    key={params}
                                    style="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 text-sm rounded"
                                    onClick={() => startTraining(params)}
                                    disabled={trainedModels[String(params)]}
                                >
                                    Train {formatModelSize(params)}
                                </Button>
                            ))}
                        </div>
                    </div>
                </Card>
            );
        }

        // --- Deployed Model Card Component ---
        function DeployedModelCard({ model, eff, upgradeModel, allocateModelGPU, setModelAllocation, totalGPUs, gpuTypeFlops, gpuCounts }) {
            const revenueScale = Math.pow(0.75, Math.log10(model.params / 1e6));
            const revPerSec = Math.sqrt(model.params) * 0.01 * revenueScale * model.gpuAllocation * model.revenueModifier * eff;

            const gpuDistribution = gpuTypeFlops.map((flops, index) => {
                const totalFlops = gpuTypeFlops.reduce((acc, f, i) => acc + f * gpuCounts[i], 0);
                return Math.round(model.gpuAllocation * ((flops * gpuCounts[index]) / totalFlops));
            });

            return (
                <div className="bg-gray-800 rounded-lg p-3">
                    <div className="flex justify-between items-center mb-2">
                        <div>
                            <div className="font-bold">{model.name}</div>
                            <div className="text-sm text-gray-400">
                                Level {model.upgradeLevel} • {model.gpuAllocation} GPUs
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-green-400 mb-1">+${revPerSec.toFixed(2)}/s</div>
                            <Button onClick={upgradeModel} style={styles.greenButton}>
                                Upgrade (${(100 * Math.pow(1.5, model.upgradeLevel)).toFixed(2)})
                            </Button>
                        </div>
                    </div>
                    <div className="flex items-center space-x-2">
                        <Button onClick={() => allocateModelGPU(-1)} style="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded">-</Button>
                        <div className="flex-1">
                            <ProgressBar
                                value={model.gpuAllocation}
                                max={totalGPUs}
                            />
                        </div>
                        <Button onClick={() => allocateModelGPU(1)} style="bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded">+</Button>
                    </div>
                </div>
            );
        }

        // --- Inference Component ---
        function Inference({ deployedModels, trainedModels, eff, upgradeModel, allocateModelGPU, setModelAllocation, setDeployedModels, formatModelSize, setStatusMessage, totalGPUs, gpuTypeFlops, gpuCounts }) {
            return (
                <Card>
                    <SectionTitle>Model Deployment</SectionTitle>
                    <div className="text-sm text-gray-400 mb-4">
                        Total GPUs Used: {deployedModels.reduce((sum, m) => sum + m.gpuAllocation, 0)}
                    </div>
                    <div className="space-y-3">
                        {deployedModels.map((model, i) => (
                            <DeployedModelCard
                                key={i}
                                model={model}
                                eff={eff}
                                upgradeModel={() => upgradeModel(i)}
                                allocateModelGPU={(delta) => allocateModelGPU(i, delta)}
                                setModelAllocation={(val) => setModelAllocation(i, val)}
                                totalGPUs={totalGPUs}
                                gpuTypeFlops={gpuTypeFlops}
                                gpuCounts={gpuCounts}
                            />
                        ))}

                        {/* Available Models Section */}
                        <div className="bg-gray-700 rounded-lg p-4">
                            <h3 className="font-bold mb-3">Available Models</h3>
                            <div className="space-y-3">
                                {Object.keys(trainedModels).filter(tm => trainedModels[tm]).map(modelKey => {
                                    const modelSize = formatModelSize(Number(modelKey));
                                    const modelName = `${modelSize} Model`;
                                    return (
                                        <div key={modelKey} className="flex items-center justify-between bg-gray-800 rounded p-3">
                                            <div>
                                                <div className="font-bold">{modelName}</div>
                                                <div className={styles.label}>Ready to deploy</div>
                                            </div>
                                            <Button onClick={() => {
                                                const newModel = {
                                                    name: modelName,
                                                    params: Number(modelKey),
                                                    gpuAllocation: 0,
                                                    upgradeLevel: 0,
                                                    powerModifier: 1.0,
                                                    revenueModifier: 1.0
                                                };
                                                setDeployedModels(dm => [...dm, newModel]);
                                                setStatusMessage(`Deployed new model: ${modelName}`);
                                            }} style={styles.button}>
                                                Deploy
                                            </Button>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                </Card>
            );
        }

        // --- Cooling Component ---
        function Cooling({ heat, coolingOptions, buyCooling }) {
            return (
                <div className="bg-gray-800 p-3 rounded-lg mb-3">
                    <h3 className="font-bold text-sm mb-2">Cooling System</h3>
                    <div className="space-y-3">
                        <div>
                            <div className="flex justify-between text-sm mb-1">
                                <span>Heat Level</span>
                                <span>{heat.toFixed(1)}/100</span>
                            </div>
                            <ProgressBar
                                value={heat}
                                max={100}
                                color={
                                    heat < 50 ? 'bg-green-500' : heat < 75 ? 'bg-yellow-500' : 'bg-red-500'
                                }
                            />
                        </div>
                        <div className="grid grid-cols-3 gap-2 text-sm">
                            {coolingOptions.map(option => (
                                <div key={option.type} className="flex flex-col gap-1">
                                    <Button onClick={() => buyCooling(option.type)} style="bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs">
                                        {option.name} (${format.currency(option.cost)})
                                    </Button>
                                    <div className="text-center text-gray-400">Owned: {option.count}</div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        // --- Power System Component ---
        function PowerSystem({ currentPowerUsage, powerCapacity, solarPanels, windTurbines, fossilFuel, buySolar, buyWind, buyGrid }) {
            const renewablePower = solarPanels * 5 + windTurbines * 7;
            return (
                <div className="bg-gray-800 p-3 rounded-lg">
                    <h3 className="font-bold text-sm mb-2">Power System</h3>
                    <div className="space-y-3">
                        <div>
                            <div className="flex justify-between text-sm mb-1">
                                <span>Power Usage</span>
                                <span>{currentPowerUsage.toFixed(1)}/{powerCapacity} kW + {renewablePower} (renewable)</span>
                            </div>
                            <ProgressBar value={currentPowerUsage} max={powerCapacity + renewablePower} color="bg-yellow-500" />
                        </div>
                        <div className="grid grid-cols-2 gap-2 text-sm">
                            <div className="flex flex-col gap-1">
                                <Button onClick={buySolar} style={styles.greenButton}>
                                    Solar ($5k)
                                </Button>
                                <div className="text-center text-gray-400">Owned: {solarPanels}</div>
                            </div>
                            <div className="flex flex-col gap-1">
                                <Button onClick={buyWind} style={styles.greenButton}>
                                    Wind ($7k)
                                </Button>
                                <div className="text-center text-gray-400">Owned: {windTurbines}</div>
                            </div>
                        </div>
                        <div className="flex flex-col gap-1">
                            <Button onClick={buyGrid} style={styles.greenButton + ' w-full'}>
                                Grid Connection ($50k)
                            </Button>
                            <div className="text-center text-gray-400 text-sm">+50 kW Capacity</div>
                        </div>
                    </div>
                </div>
            );
        }

        // --- Power Management Component ---
        function PowerManagement({ heat, coolingOptions, buyCooling, currentPowerUsage, powerCapacity, solarPanels, windTurbines, fossilFuel, buySolar, buyWind, buyGrid }) {
            return (
                <Card>
                    <SectionTitle>Power Management</SectionTitle>
                    <Cooling heat={heat} coolingOptions={coolingOptions} buyCooling={buyCooling} />
                    <PowerSystem
                        currentPowerUsage={currentPowerUsage}
                        powerCapacity={powerCapacity}
                        solarPanels={solarPanels}
                        windTurbines={windTurbines}
                        fossilFuel={fossilFuel}
                        buySolar={buySolar}
                        buyWind={buyWind}
                        buyGrid={buyGrid}
                    />
                </Card>
            );
        }

        // --- Active Models Component ---
        function ActiveModels({ deployedModels, eff, gpuTypeFlops, gpuCounts, parallelGroups }) {
            return (
                <Card>
                    <h3 className="font-bold mb-4">System Monitoring</h3>
                    <div className="space-y-4">
                        <div>
                            <div className="flex justify-between text-sm mb-1">
                                <span className="text-gray-400">System Efficiency</span>
                                <span className="text-green-400">{(eff * 100).toFixed(0)}%</span>
                            </div>
                            <ProgressBar value={eff * 100} max={100} color="bg-green-500" />
                        </div>
                        <div>
                            <div className="flex justify-between text-sm mb-1">
                                <span className="text-gray-400">GPU Utilization</span>
                                <span className="text-blue-400">{
                                    (gpuCounts.reduce((sum, c, i) => sum + c + parallelGroups[i] * 4, 0)) === 0 ?
                                        '0' :
                                        (deployedModels.reduce((sum, m) => sum + m.gpuAllocation, 0) / (gpuCounts.reduce((sum, c, i) => sum + c + parallelGroups[i] * 4, 0)) * 100).toFixed(0)
                                }%</span>
                            </div>
                            <ProgressBar value={deployedModels.reduce((sum, m) => sum + m.gpuAllocation, 0)} max={gpuCounts.reduce((sum, c, i) => sum + c + parallelGroups[i] * 4, 0)} color="bg-blue-500" />
                        </div>
                        {/* You can add more monitoring stats here */}
                    </div>
                </Card>
            );
        }

        // --- System Status Component ---
        function SystemStatus({ eff, heat, statusMessage, parallelGroups, gpuCounts, deployedModels, trainedModels, revPerSec, getTotalFlops }) {
            return (
                <Card>
                    <h3 className="font-bold mb-4">Performance History</h3>
                    <div className="space-y-2 text-sm">
                        <div className="flex justify-between">
                            <span className="text-gray-400">Peak FLOPS Today</span>
                            <span>{(getTotalFlops() * eff).toExponential(2)}</span>
                        </div>
                        <div className="flex justify-between">
                            <span className="text-gray-400">Avg. GPU Utilization</span>
                            <span>{
                                (gpuCounts.reduce((sum, c, i) => sum + c + parallelGroups[i] * 4, 0)) === 0 ?
                                    '0' :
                                    (deployedModels.reduce((sum, m) => sum + m.gpuAllocation, 0) / (gpuCounts.reduce((sum, c, i) => sum + c + parallelGroups[i] * 4, 0)) * 100).toFixed(0)
                            }%</span>
                        </div>
                        <div className="flex justify-between">
                            <span className="text-gray-400">Total Models Trained</span>
                            <span>{Object.values(trainedModels).filter(t => t).length}</span>
                        </div>
                        <div className="flex justify-between">
                            <span className="text-gray-400">Revenue (24h)</span>
                            <span className="text-green-400">${(revPerSec * 3600 * 24).toFixed(2)}</span>
                        </div>
                    </div>
                </Card>
            );
        }
        // --- Footer Component ---
        function Footer() {
            return (
                <Card>
                    <div>
                        <a href="https://lab.simonwisdom.com" className="text-blue-600 underline">
                            lab.simonwisdom.com
                        </a>
                    </div>
                </Card>
            );
        }

        // --- Custom Hooks ---
        const useGameState = () => {
            // --- STATE HOOKS ---
            const [money, setMoney] = React.useState(20);
            const [gpuCounts, setGpuCounts] = React.useState([1, 0, 0]); // RTX 4090, A6000, H100 SXM5
            const [parallelGroups, setParallelGroups] = React.useState([0, 0, 0]);
            const [heat, setHeat] = React.useState(0);
            const [coolingCounts, setCoolingCounts] = React.useState([0, 0, 0]); // Basic, Advanced, Industrial
            const [fossilFuel, setFossilFuel] = React.useState(100);
            const [powerCapacity, setPowerCapacity] = React.useState(20);
            const [currentPowerUsage, setCurrentPowerUsage] = React.useState(0);
            const [solarPanels, setSolarPanels] = React.useState(0);
            const [windTurbines, setWindTurbines] = React.useState(0);
            const [isTraining, setIsTraining] = React.useState(false);
            const [trainGPUs, setTrainGPUs] = React.useState(0);
            const [currentModelParams, setCurrentModelParams] = React.useState(0);
            const [trainingProgress, setTrainingProgress] = React.useState(0);
            const [trainedModels, setTrainedModels] = React.useState({
                '1e6': false,
                '1e9': false,
                '1e10': false,
                '1e11': false,
                '1e12': false,
            });
            const [deployedModels, setDeployedModels] = React.useState([]);
            const [statusMessage, setStatusMessage] = React.useState('Ready.');

            // --- CONSTANTS ---
            const gpuTypeCosts = [1600, 4800, 30400];
            const gpuTypeFlops = [8.26e13, 1.497e14, 9.89e14];
            const gpuTypePowerHour = [0.09, 0.07, 0.15];
            const gpuTypeHeatFactor = [3.0, 4.0, 8.0];
            const parallelBoostFactor = 4.0;

            const coolingOptions = [
                { type: 'basic', name: 'Basic Fan', cost: 2000, count: coolingCounts[0], coolingRate: 1 },
                { type: 'advanced', name: 'Adv Fan', cost: 7500, count: coolingCounts[1], coolingRate: 4 },
                { type: 'industrial', name: 'Industrial', cost: 25000, count: coolingCounts[2], coolingRate: 12 }
            ];

            const tokenCostPerMillion = 0.5;
            const trainingFlopsCoefficient = 0.1;
            const trainingFlopsScale = 1e-4;
            const revenueCoefficient = 0.01;
            const baseUpgradeCost = 100;
            const upgradePowerFactor = 0.9, upgradeRevenueFactor = 1.2;
            const upgradeCostScale = 1.5;

            // --- DERIVED STATE ---
            const getTotalGPUs = React.useCallback(() => {
                return gpuCounts.reduce((sum, count) => sum + count, 0)
                    + parallelGroups.reduce((sum, count) => sum + count, 0) * 4;
            }, [gpuCounts, parallelGroups]);

            const getTotalFlops = React.useCallback(() => {
                return gpuTypeFlops.reduce((sum, flops, i) =>
                    sum + parallelGroups[i] * (4 * flops * parallelBoostFactor) + gpuCounts[i] * flops, 0);
            }, [gpuCounts, parallelGroups, gpuTypeFlops]);

            const clampAllAllocations = React.useCallback((tGPUs, dModels, newTrainGPUs) => {
                let sumAlloc = newTrainGPUs + dModels.reduce((s, m) => s + m.gpuAllocation, 0);
                if (sumAlloc <= tGPUs) return { trainGPUs: newTrainGPUs, deployed: dModels };

                let leftover = sumAlloc - tGPUs;
                const newDeployed = [...dModels];
                for (let i = newDeployed.length - 1; i >= 0 && leftover > 0; i--) {
                    const reduce = Math.min(leftover, newDeployed[i].gpuAllocation);
                    newDeployed[i] = { ...newDeployed[i], gpuAllocation: newDeployed[i].gpuAllocation - reduce };
                    leftover -= reduce;
                }
                return { trainGPUs: Math.max(0, newTrainGPUs - leftover), deployed: newDeployed };
            }, []);



            // --- LOGIC FUNCTIONS ---
            const updatePower = React.useCallback((totalGPUs) => {
                const idlePower = 0.2 * totalGPUs;
                let trainingPower = isTraining && trainGPUs > 0 ? 20 * Math.min(1, trainGPUs / totalGPUs) : 0;
                let servingPower = deployedModels.reduce((sum, m) => sum + (m.gpuAllocation > 0 ? 2 : 0), 0);
                const coolingPower = coolingOptions.reduce((sum, option) => sum + option.count * option.coolingRate * 0.1, 0);

                let newPowerUsage = idlePower + trainingPower + servingPower + coolingPower;
                const totalRenewables = solarPanels * 5 + windTurbines * 7;
                const availablePower = powerCapacity + totalRenewables;

                if (newPowerUsage > availablePower) {
                    if (isTraining) {
                        setIsTraining(false);
                        setTrainingProgress(tp => Math.max(tp - 1, 0));
                        setStatusMessage('Training halted due to power shortage!');
                    }
                    newPowerUsage = availablePower;
                }

                let consumptionPerSecond = newPowerUsage / 3600 * 0.1;
                setFossilFuel(ff => {
                    let nextFF = ff - consumptionPerSecond;
                    if (nextFF < 0) {
                        nextFF = 0;
                        setStatusMessage('Fossil fuel depleted!');
                    }
                    if (nextFF <= 0 && newPowerUsage > totalRenewables) {
                        newPowerUsage = totalRenewables;
                        setStatusMessage('Running on renewables only; limited performance.');
                    }
                    return nextFF;
                });

                setCurrentPowerUsage(newPowerUsage);
            }, [isTraining, trainGPUs, deployedModels, coolingOptions, solarPanels, windTurbines, powerCapacity]);

            const updateHeat = React.useCallback((totalGPUs) => {
                const totalInUse = trainGPUs + deployedModels.reduce((s, m) => s + m.gpuAllocation, 0);
                setHeat(h => {
                    let newHeat = h;
                    if (totalInUse < 1 || totalGPUs < 1) {
                        newHeat -= 0.1;
                    } else {
                        const usageRatio = Math.min(1, totalInUse / totalGPUs);
                        let heatGenerated = gpuTypeHeatFactor.reduce((sum, factor, i) =>
                            sum + usageRatio * (gpuCounts[i] + parallelGroups[i] * 4) * factor, 0) * 0.1;
                        heatGenerated *= (1.0 + parallelGroups.reduce((sum, count) => sum + count, 0) * 0.3);
                        const heatRemoved = coolingOptions.reduce((sum, option) => sum + option.count * option.coolingRate, 0) * 0.1;
                        newHeat += (heatGenerated - heatRemoved);
                    }
                    newHeat = Math.max(0, Math.min(newHeat, 100));
                    if (newHeat >= 90 && Math.random() < 0.002 && totalGPUs > 0) {
                        randomRemoveOneGPU();
                        setStatusMessage('One GPU failed due to overheating!');
                    }
                    return newHeat;
                });
            }, [trainGPUs, deployedModels, gpuCounts, parallelGroups, gpuTypeHeatFactor, coolingOptions]);

            const effectiveEfficiency = React.useCallback(() => {
                const totalRaw = gpuTypeFlops.reduce((sum, flops, i) => sum + (gpuCounts[i] + parallelGroups[i] * 4) * flops, 0);
                const totalReal = gpuTypeFlops.reduce((sum, flops, i) =>
                    sum + (gpuCounts[i] * flops) + parallelGroups[i] * 4 * flops * parallelBoostFactor, 0);
                let ratio = totalRaw > 0 ? totalReal / totalRaw : 1.0;

                if (heat >= 25) ratio *= 0.9;
                if (heat >= 50) ratio *= 0.6;
                if (heat >= 75) ratio *= 0.3;
                if (heat >= 90) ratio *= 0.15;
                return ratio;
            }, [gpuCounts, parallelGroups, gpuTypeFlops, heat]);

            const updateTraining = React.useCallback(() => {
                if (!isTraining || currentModelParams <= 0 || trainGPUs <= 0) return;

                const neededTokens = currentModelParams * 20;
                const flopsNeeded = trainingFlopsCoefficient * currentModelParams * neededTokens * trainingFlopsScale;
                const tGPUs = getTotalGPUs();
                if (tGPUs === 0) return;

                const trainingFrac = trainGPUs / tGPUs;
                const allocatedFlops = getTotalFlops() * trainingFrac;
                const flopsThisTick = allocatedFlops * 0.1 * effectiveEfficiency();
                const fractionDone = flopsThisTick / flopsNeeded;

                setTrainingProgress(tp => {
                    const newProg = tp + fractionDone * 100;
                    if (newProg >= 100) {
                        finishTraining();
                        return 100;
                    }
                    return newProg;
                });
            }, [isTraining, currentModelParams, trainGPUs, getTotalGPUs, getTotalFlops, effectiveEfficiency, trainingFlopsCoefficient, trainingFlopsScale]);

            const finishTraining = React.useCallback(() => {
                setIsTraining(false);
                setTrainedModels(prev => ({ ...prev, [String(currentModelParams)]: true }));

                const newModelName = `${format.modelSize(currentModelParams)} Params Model`;
                const newModel = {
                    name: newModelName,
                    params: currentModelParams,
                    gpuAllocation: 0,
                    upgradeLevel: 0,
                    powerModifier: 1.0,
                    revenueModifier: 1.0
                };
                setDeployedModels(dm => [...dm, newModel]);
                setStatusMessage(`Training complete! Deployed new model: ${newModelName}`);
                setCurrentModelParams(0);
            }, [currentModelParams]);

            const generateRevenue = React.useCallback(() => {
                const eff = effectiveEfficiency();
                setMoney(prevMoney => {
                    let newMoney = prevMoney;
                    for (let m of deployedModels) {
                        if (m.gpuAllocation > 0) {
                            const revenueScale = Math.pow(0.75, Math.log10(m.params / 1e6));
                            const revPerSec = Math.sqrt(m.params) * revenueCoefficient * revenueScale * m.gpuAllocation * m.revenueModifier * eff;
                            newMoney += revPerSec * 0.1;
                        }
                    }
                    return newMoney;
                });
            }, [deployedModels, effectiveEfficiency, revenueCoefficient]);

            const consumePower = React.useCallback((totalGPUs) => {
                const tInUse = trainGPUs + deployedModels.reduce((s, m) => s + m.gpuAllocation, 0);
                if (tInUse < 1 || totalGPUs < 1) return;

                const usageRatio = Math.min(1, tInUse / totalGPUs);
                const powerCost = gpuTypePowerHour.reduce((sum, powerHour, i) =>
                    sum + (powerHour / 3600) * usageRatio * (gpuCounts[i] + parallelGroups[i] * 4), 0) * 0.1;

                setMoney(m => {
                    const newVal = m - powerCost;
                    return newVal < 0 ? 0 : newVal;
                });
            }, [trainGPUs, deployedModels, gpuCounts, parallelGroups, gpuTypePowerHour]);

            const checkWinCondition = React.useCallback(() => {
                if (getTotalFlops() >= 2e29) {
                    setStatusMessage('You have reached 2e29 FLOPS capacity. You win!');
                }
            }, [getTotalFlops]);

            // --- GAME LOOP (using useCallback for memoization) ---
            const gameLoop = React.useCallback(() => {
                const totalGPUs = getTotalGPUs();
                updatePower(totalGPUs);
                updateHeat(totalGPUs);
                updateTraining();
                generateRevenue();
                consumePower(totalGPUs);
                checkWinCondition();
            }, [getTotalGPUs, updatePower, updateHeat, updateTraining, generateRevenue, consumePower, checkWinCondition]);

            React.useEffect(() => {
                const timer = setInterval(gameLoop, 100);
                return () => clearInterval(timer);
            }, [gameLoop]);

            // --- ACTIONS ---
            const buyGPU = React.useCallback((typeIndex) => {
                if (money < gpuTypeCosts[typeIndex]) {
                    setStatusMessage('Not enough money to buy this GPU!');
                    return;
                }
                setMoney(m => m - gpuTypeCosts[typeIndex]);
                setGpuCounts(counts => counts.map((count, i) => i === typeIndex ? count + 1 : count));
                setStatusMessage('GPU purchased!');
            }, [money, gpuTypeCosts]);

            const parallelizeGPU = React.useCallback((typeIndex) => {
                if (gpuCounts[typeIndex] < 4) {
                    setStatusMessage('Not enough GPUs to form a group of 4!');
                    return;
                }
                const cost = 150000 + 75000 * parallelGroups[typeIndex];
                if (money < cost) {
                    setStatusMessage('Not enough money to parallelize!');
                    return;
                }
                setMoney(m => m - cost);
                setParallelGroups(pg => pg.map((count, i) => i === typeIndex ? count + 1 : count));
                setGpuCounts(counts => counts.map((count, i) => i === typeIndex ? count - 4 : count));
                setStatusMessage(`Parallelized 4 GPUs of type ${typeIndex}!`);
            }, [gpuCounts, parallelGroups, money]);

            const startTraining = React.useCallback((params) => {
                if (isTraining) {
                    setStatusMessage('A training job is already in progress.');
                    return;
                }
                if (trainedModels[String(params)]) {
                    setStatusMessage('This model was already trained. You can’t train it again.');
                    return;
                }
                const costForTokens = params * 20 / 1e6 * tokenCostPerMillion;
                if (money < costForTokens) {
                    setStatusMessage('Not enough money for token purchase!');
                    return;
                }
                setMoney(m => m - costForTokens);
                setIsTraining(true);
                setTrainingProgress(0);
                setCurrentModelParams(params);
                setStatusMessage(`Started training ${format.modelSize(params)} params model.`);
            }, [isTraining, trainedModels, tokenCostPerMillion, money]);

            const changeTrainGPU = React.useCallback((delta) => {
                const newVal = Math.max(0, trainGPUs + delta);
                const { trainGPUs: cT, deployed } = clampAllAllocations(getTotalGPUs(), deployedModels, newVal);
                setTrainGPUs(cT);
                setDeployedModels(deployed);
            }, [trainGPUs, clampAllAllocations, getTotalGPUs, deployedModels]);

            const setTrainGPUInput = React.useCallback((val) => {
                const newVal = Math.max(0, Number(val) || 0);
                const { trainGPUs: cT, deployed } = clampAllAllocations(getTotalGPUs(), deployedModels, newVal);
                setTrainGPUs(cT);
                setDeployedModels(deployed);
            }, [clampAllAllocations, getTotalGPUs, deployedModels]);

            const allocateModelGPU = React.useCallback((index, delta) => {
                const dCopy = [...deployedModels];
                const newVal = dCopy[index].gpuAllocation + delta;
                dCopy[index] = { ...dCopy[index], gpuAllocation: Math.max(0, newVal) };
                const { trainGPUs: cT, deployed } = clampAllAllocations(getTotalGPUs(), dCopy, trainGPUs);
                setTrainGPUs(cT);
                setDeployedModels(deployed);
            }, [deployedModels, clampAllAllocations, getTotalGPUs, trainGPUs]);

            const setModelAllocation = React.useCallback((index, val) => {
                const nVal = Math.max(0, Number(val) || 0);
                const dCopy = [...deployedModels];
                dCopy[index] = { ...dCopy[index], gpuAllocation: nVal };
                const { trainGPUs: cT, deployed } = clampAllAllocations(getTotalGPUs(), dCopy, trainGPUs);
                setTrainGPUs(cT);
                setDeployedModels(deployed);
            }, [deployedModels, clampAllAllocations, getTotalGPUs, trainGPUs]);

            const upgradeModel = React.useCallback((index) => {
                const model = deployedModels[index];
                const cost = baseUpgradeCost * Math.pow(upgradeCostScale, model.upgradeLevel);
                if (money < cost) {
                    setStatusMessage('Not enough money to upgrade!');
                    return;
                }
                setMoney(m => m - cost);
                const newModel = {
                    ...model,
                    upgradeLevel: model.upgradeLevel + 1,
                    powerModifier: model.powerModifier * upgradePowerFactor,
                    revenueModifier: model.revenueModifier * upgradeRevenueFactor
                };
                setDeployedModels(dm => dm.map((m, i) => i === index ? newModel : m));
                setStatusMessage(`${model.name} upgraded to level ${newModel.upgradeLevel}!`);
            }, [deployedModels, baseUpgradeCost, upgradeCostScale, money, upgradePowerFactor, upgradeRevenueFactor]);

            const buyCooling = React.useCallback((type) => {
                const option = coolingOptions.find(o => o.type === type);
                if (money < option.cost) {
                    setStatusMessage(`Not enough money for ${option.name}.`);
                    return;
                }
                setMoney(m => m - option.cost);
                setCoolingCounts(counts => counts.map((count, i) => i === coolingOptions.indexOf(option) ? count + 1 : count));
                setStatusMessage(`Bought a ${option.name}!`);
            }, [money, coolingOptions]);

            const buySolar = React.useCallback(() => {
                if (money < 5000) {
                    setStatusMessage('Not enough money for Solar Panel!');
                    return;
                }
                setMoney(m => m - 5000);
                setSolarPanels(sp => sp + 1);
                setStatusMessage('Bought a Solar Panel!');
            }, [money]);

            const buyWind = React.useCallback(() => {
                if (money < 7000) {
                    setStatusMessage('Not enough money for Wind Turbine!');
                    return;
                }
                setMoney(m => m - 7000);
                setWindTurbines(w => w + 1);
                setStatusMessage('Bought a Wind Turbine!');
            }, [money]);

            const buyGrid = React.useCallback(() => {
                if (money < 50000) {
                    setStatusMessage('Not enough money for Grid Connection!');
                    return;
                }
                setMoney(m => m - 50000);
                setPowerCapacity(pc => pc + 50);
                setStatusMessage('Connected to the Grid! +50 kW capacity');
            }, [money]);

            const randomRemoveOneGPU = React.useCallback(() => {
                const result = [];
                if (gpuCounts[0] > 0) result.push('t1');
                if (gpuCounts[1] > 0) result.push('t2');
                if (gpuCounts[2] > 0) result.push('t3');
                if (parallelGroups[0] > 0) result.push('pg0');
                if (parallelGroups[1] > 0) result.push('pg1');
                if (parallelGroups[2] > 0) result.push('pg2');
                if (!result.length) return;

                const choice = result[Math.floor(Math.random() * result.length)];
                if (choice === 't1') setGpuCounts(c => [c[0] - 1, c[1], c[2]]);
                if (choice === 't2') setGpuCounts(c => [c[0], c[1] - 1, c[2]]);
                if (choice === 't3') setGpuCounts(c => [c[0], c[1], c[2] - 1]);
                if (choice === 'pg0') setParallelGroups(p => [p[0] - 1, p[1], p[2]]);
                if (choice === 'pg1') setParallelGroups(p => [p[0], p[1] - 1, p[2]]);
                if (choice === 'pg2') setParallelGroups(p => [p[0], p[1], p[2] - 1]);
            }, [gpuCounts, parallelGroups]);

            return {
                money,
                gpuCounts,
                parallelGroups,
                heat,
                coolingCounts,
                fossilFuel,
                powerCapacity,
                currentPowerUsage,
                solarPanels,
                windTurbines,
                isTraining,
                trainGPUs,
                currentModelParams,
                trainingProgress,
                trainedModels,
                deployedModels,
                statusMessage,
                gpuTypeCosts,
                gpuTypeFlops,
                coolingOptions,
                getTotalGPUs,
                getTotalFlops,
                effectiveEfficiency,
                buyGPU,
                parallelizeGPU,
                startTraining,
                changeTrainGPU,
                setTrainGPUInput,
                allocateModelGPU,
                setModelAllocation,
                upgradeModel,
                buyCooling,
                buySolar,
                buyWind,
                buyGrid,
                setDeployedModels,
                setStatusMessage,
            };
        };

        // --- MAIN GAME COMPONENT ---
        function GameUI() {
            const {
                money, gpuCounts, parallelGroups, heat, coolingCounts,
                fossilFuel, powerCapacity, currentPowerUsage, solarPanels,
                windTurbines, isTraining, trainGPUs, currentModelParams,
                trainingProgress, trainedModels, deployedModels, statusMessage,
                gpuTypeCosts, gpuTypeFlops, coolingOptions,
                getTotalGPUs, getTotalFlops, effectiveEfficiency,
                buyGPU, parallelizeGPU, startTraining, changeTrainGPU,
                setTrainGPUInput, allocateModelGPU, setModelAllocation,
                upgradeModel, buyCooling, buySolar, buyWind,
                buyGrid, setDeployedModels, setStatusMessage
            } = useGameState();

            // --- RENDER ---
            const eff = effectiveEfficiency();
            const totalFlopsDisplay = getTotalFlops().toExponential(2);
            const revPerSec = deployedModels.reduce((totalRev, m) => {
                if (m.gpuAllocation > 0) {
                    const revenueScale = Math.pow(0.75, Math.log10(m.params / 1e6));
                    return totalRev + Math.sqrt(m.params) * 0.01 * revenueScale * m.gpuAllocation * m.revenueModifier * eff;
                }
                return totalRev;
            }, 0);

            const gpuTypes = [
                { name: 'RTX 4090', count: gpuCounts[0] },
                { name: 'A6000', count: gpuCounts[1] },
                { name: 'H100 SXM5', count: gpuCounts[2] }
            ];

            return (
                <div className="min-h-screen bg-gray-900 text-white">
                    <CoreResourceBar
                        money={money}
                        revPerSec={revPerSec}
                        totalFlopsDisplay={totalFlopsDisplay}
                        currentPowerUsage={currentPowerUsage}
                        powerCapacity={powerCapacity}
                        solarPanels={solarPanels}
                        windTurbines={windTurbines}
                        heat={heat}
                    />

                    <div className="container mx-auto p-4">
                        <div className="grid grid-cols-12 gap-4">
                            {/* Left Column - GPU & Power Management */}
                            <div className="col-span-4 space-y-4">
                                <GPUManagement
                                    gpuTypes={gpuTypes}
                                    parallelGroups={parallelGroups}
                                    buyGPU={buyGPU}
                                    parallelizeGPU={parallelizeGPU}
                                    gpuTypeCosts={gpuTypeCosts}
                                    gpuTypeFlops={gpuTypeFlops}
                                />
                                <PowerManagement
                                    heat={heat}
                                    coolingOptions={coolingOptions}
                                    buyCooling={buyCooling}
                                    currentPowerUsage={currentPowerUsage}
                                    powerCapacity={powerCapacity}
                                    solarPanels={solarPanels}
                                    windTurbines={windTurbines}
                                    fossilFuel={fossilFuel}
                                    buySolar={buySolar}
                                    buyWind={buyWind}
                                    buyGrid={buyGrid}
                                />
                            </div>

                            {/* Middle Column - Training & Inference */}
                            <div className="col-span-5 space-y-4">
                                <TrainingCenter
                                    isTraining={isTraining}
                                    currentModelParams={currentModelParams}
                                    trainingProgress={trainingProgress}
                                    trainGPUs={trainGPUs}
                                    trainedModels={trainedModels}
                                    changeTrainGPU={changeTrainGPU}
                                    setTrainGPUInput={setTrainGPUInput}
                                    startTraining={startTraining}
                                    formatModelSize={format.modelSize}
                                />
                                <Inference
                                    deployedModels={deployedModels}
                                    trainedModels={trainedModels}
                                    eff={eff}
                                    upgradeModel={upgradeModel}
                                    allocateModelGPU={allocateModelGPU}
                                    setModelAllocation={setModelAllocation}
                                    setDeployedModels={setDeployedModels}
                                    formatModelSize={format.modelSize}
                                    setStatusMessage={setStatusMessage}
                                    totalGPUs={getTotalGPUs()}
                                    gpuTypeFlops={gpuTypeFlops}
                                    gpuCounts={gpuCounts}
                                />
                            </div>

                            {/* Right Column - Monitoring & Footer */}
                            <div className="col-span-3 space-y-4">
                                <ActiveModels
                                    deployedModels={deployedModels}
                                    eff={eff}
                                    gpuTypeFlops={gpuTypeFlops}
                                    gpuCounts={gpuCounts}
                                    parallelGroups={parallelGroups}
                                />
                                <SystemStatus
                                    eff={eff}
                                    heat={heat}
                                    statusMessage={statusMessage}
                                    parallelGroups={parallelGroups}
                                    gpuCounts={gpuCounts}
                                    deployedModels={deployedModels}
                                    trainedModels={trainedModels}
                                    revPerSec={revPerSec}
                                    getTotalFlops={getTotalFlops}
                                />
                                <Footer />
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Render with error boundary
        const root = ReactDOM.createRoot(document.getElementById('root'));
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true };
            }

            render() {
                if (this.state.hasError) {
                    return <div className="p-4 text-red-600">Something went wrong. Please refresh the page.</div>;
                }
                return this.props.children;
            }
        }

        root.render(
            <ErrorBoundary>
                <GameUI />
            </ErrorBoundary>
        );
    </script>

    <!-- Progressive enhancement -->
    <noscript>
        <div class="p-4">
            Please enable JavaScript to play this game.
        </div>
    </noscript>

    <script>
        window.addEventListener('load', function () {
            if (!window.React || !window.ReactDOM || !window.Babel) {
                console.log('Missing:', {
                    React: !!window.React,
                    ReactDOM: !!window.ReactDOM,
                    Babel: !!window.Babel
                });
                document.getElementById('root').innerHTML =
                    '<div class="p-4">Your browser may not support this application. Missing required libraries.</div>';
            }
        });
    </script>
</body>

</html>